{"name":"Syncing Clocks ","tagline":"A complete guide to synchronize clocks in distributed environment","body":"# Welcome to the Clock Synchronization - Linux wiki!\r\nThis project is created in response to the requirement in CSE536- Advanced Operating System. We choose **Linux** for our project because it is open source as well as free. In addition, it is easily customizable because we have source code, compiling tools as well as online forums and blogs for help. In all, in terms of cost, support and legality of use, Linux is the best choice. For this project we used Ubuntu 14.04.1 LTS. The project itself is divided in 3 parts.\r\n\r\nBefore using any tool or software, the basic requirement is that we should be able to install it on our system. That’s why first step of [part-1](https://github.com/rajeshsurana/Clock_Synchronization_Linux/blob/master/Project1/Project%201%20Formal%20Report.pdf) is installation of Ubuntu. Goal is to make ourselves comfortable with the GUI of the Ubuntu and its functionalities such as terminal, text editor or compiler. It is important to understand how to update the software to get the latest security mechanisms as well as new utilities. Same analogy applies to kernel also. In fact, update of kernel is not just meant to be better functionality but an environment which is more secure and bug free. That’s why our second step of part-1 is to understand how to update a kernel to its latest revision. Perk of part-1 is at last where we get to know the typical structure of kernel module. We even devise a way to debug a kernel module on top of which debugger run.\r\n\r\nIn [part-2](https://github.com/rajeshsurana/Clock_Synchronization_Linux/blob/master/Project2/Project2.pdf), we build a communication channel that uses normal read/write system calls to communicate over IP. Here, we replace the standard socket interface used by most network programs and allow one application to communicate in full duplex via ipv4. Ipv4 is not to be altered. A write on system A will fill a read buffer on system B and visa-versa.\r\n\r\n[Part-3](https://github.com/rajeshsurana/Clock_Synchronization_Linux/blob/master/Project3/Project3.pdf) uses part-2 to communicate between machines to implement a logical clock. When sending a message from system A to system B we want to have an ordering to determine among several messages which came first.\r\n\r\nFor complete report please click [here](https://github.com/rajeshsurana/Clock_Synchronization_Linux/blob/master/Formal_Report/Formal_Report_CSE536.pdf).\r\n\r\n## Snapshots of the application\r\n\r\n1. Sender (IP address = 192.168.0.40)\r\n![Sender (IP address = 192.168.0.40)](https://raw.githubusercontent.com/rajeshsurana/Clock_Synchronization_Linux/master/Project3/img1.jpg)\r\n\r\n2. Kernel Traces on sender side\r\n![Kernel Traces on sender side](https://raw.githubusercontent.com/rajeshsurana/Clock_Synchronization_Linux/master/Project3/img2.jpg)\r\n\r\n3. Receiver (IP address = 192.168.0.41)\r\n![Receiver (IP address = 192.168.0.41)](https://raw.githubusercontent.com/rajeshsurana/Clock_Synchronization_Linux/master/Project3/img3.jpg)\r\n\r\n4. Kernel Traces on receiver side\r\n![Kernel Traces on receiver side](https://raw.githubusercontent.com/rajeshsurana/Clock_Synchronization_Linux/master/Project3/img4.jpg)\r\n\r\n5. Monitor after the events and acknowledgements\r\n![Monitor after the events and acknowledgements](https://raw.githubusercontent.com/rajeshsurana/Clock_Synchronization_Linux/master/Project3/img5.jpg)\r\n\r\n*Note: The problem statements are provided by prof. Skousen.\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}